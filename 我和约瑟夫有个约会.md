```
\*用了四个小时左右（不包括学习新内容的时间），
最开始做得很流畅但做完后出现乱码实在想不出怎么解决
只有慢慢更改方法花费了很多时间
再加上审题不是很清楚（做完了也不清楚写的输出格式到底对不对）
总之感觉过程太难了*\
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct node//声明结构体
{
    int data;
    int order;//记录每个节点的位置
    struct node *next;
}Node;
//函数声明
Node *createList();
void T(Node *node,int *nums);
void printNodeList(Node *node);
void C(Node *node);
int DeleteNode (Node *p1);
void freeList(Node *head);
void orderList(Node *head);
int main()
{
    int nums[34] = {1,2,1,1,1,2,1,1,1,1,2,2,2,2,1,2,1,1,3,1,1,2,1,2,2,2,2,1,1,2,2,1,1,1};
    Node *head =createList();
    T(head,nums);
    C(head);//创建链表

    Node *current = head;  
    int wei = 0; //记录删除的位序

//找到数据为3的节点
    while(current->data != 3){
        current = current->next;
    }
    orderList(current);//从数据为3的节点开始记录位序1，2，3····
    printNodeList(head);
    wei = DeleteNode (current);
    int count = 1;

    printf("第%d个删除的位序为:%d\n", count, wei);//打印删除节点的位序

//删除各个节点
    while(current->next!= current){
        head = current;
        int i =0;
        for(i=0; i<count; i++){
        current = current->next;
    }
        int wei = DeleteNode (current);
        count++;
        printf("第%d个删除的位序为:%d\n", count, wei);
    }
    printf("最后删除的位序为%d", head->order);
    //printNodeList(head);
    freeList(head);//将链表全部释放

    return 0;
}
Node *createList(){
    Node *head = (Node *)malloc(sizeof(Node));
    if (head == NULL){
        return NULL;
    }
    head->next = NULL;
    head->data = 1;
    
    return head;
}
void T(Node *node,int *nums){
    int num = 1;
    while(num < 34){
        Node *cur = (Node *)malloc(sizeof(Node));
        cur->data = nums[num++];//存入数据
        
        Node *locate = node;
        while(locate->next != NULL){
            locate = locate->next;//使用指针找到最后一个节点
        } 

        locate->next = cur;
        cur->next = NULL;//尾部插入节点
    }
}
void printNodeList(Node *node){
    Node *print1 = node;
    Node *print2 = node;

    if (node == NULL) {
        printf("链表为空\n");
        return;
    }

    do
    {   printf("数据为%d位序为:%d   ", print1->data, print1->order);
        print1 = print1->next;
    }while(print1 != print2);//定义两个指针运用do while结构进行输出
        //（自己琢磨的不知道正规思路应该怎么做）
    printf("\n");
}
//创建循环链表
void C(Node *node){
    Node *connect = node;//定义指针
    while(connect->next != NULL){
        connect = connect->next;//找到最后一个节点
    }
    connect->next = node;//连接收尾节点
}

//删除指定结点 p
int DeleteNode (Node *p1) {
    int temp;
    if (p1 == NULL)
        return 0;

    Node *p2=p1->next;
    p1->data=p1->next->data;//交换数据域
    p1->next=p2->next;
    temp = p2->order;
    free(p2);
    return temp;
}
//释放内存
void freeList(Node *head) {
       Node *current = head;
       Node *next;
       while (current!= NULL) {
           next = current->next;
           free(current);
           current = next;
       }
   }
//记录位序
void orderList(Node *head){
    Node *temp = head;
    int t =1;

    while(temp->order != 1){
        temp->order = t;
        t++;
        temp = temp->next;
    }
}   